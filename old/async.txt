def get_deputy_interventions_list(
        self,
        dep_name,
        count=500,
        object_name="Intervention",
        sort=0,
        page=1,
        all_pages=False,
        max_interventions=1000,
    ):
        """Retrieves the urls of the interventions of a parliamentarian.

        See the documentation for the API for more information:
        https://github.com/regardscitoyens/nosdeputes.fr/blob/master/doc/api.md#r%C3%A9sultats-du-moteur-de-recherche

        Args:
            slug_name: The slug name of the parliamentarian.
                `prenom+nom` sans accents ni cédille et en remplaçant les espaces par des +,
                mais en conservant les traits d'union.
            count: The number of interventions to retrieve.
                Default: 500.
            object_name: The type of object to retrieve.
                Intervention, Amendement, QuestionEcrite, Commentaire, Parlementaire, Organisme.
                Default: "Intervention".
            sort: The sort order of the interventions, by pertinence or by date.
                Default: 0.
            page: The page of results to retrieve.
                Default: 1.
            all_pages: Whether to retrieve all pages of results.
                Default: False.

        Returns:
            A json object containing the links to the interventions.
        """
        if all_pages or max_interventions:
            page = 1

        # Remove accents and special characters from the name and replace spaces with +
        name = self.search_parlementaires(dep_name)[0][0]["nom"]
        slug_name = re.sub(" ", "+", unidecode.unidecode(name.lower()))

        # Build the URL for the search
        url = f"{self.base_url}/recherche?object_name={object_name}&format={self.format}"
        url += f"&tag=parlementaire%3D{slug_name}&count={count}&sort={sort}"
        page_param = f"&page={page}"

        # Retrieve the search results
        response = requests.get(url + page_param).json()
        response["dep_name"] = dep_name
        response["slug_name"] = slug_name
        response["legislature"] = self.legislature_name

        # Fetch other pages if necessary
        if all_pages:
            last_int = response["last_result"]
        else:
            last_int = min(max_interventions, response["last_result"])

        while all_pages and response["end"] < last_int:
            page += 1
            page_param = f"&page={page}"

            tmp = requests.get(url + page_param).json()
            response["results"] += tmp["results"]
            response["end"] = tmp["end"]

        return response

    def get_all_interventions_urls(
        self,
        all_pages=True,
        max_interventions=1000,
        sort=0,
        count=500,
        object_name="Intervention",
        page=1,
        verbose=True,
        save="./data/interventions_urls_by_deputies.json",
    ):
        """Retrieves the URLs for all interventions by each deputy.

        Parameters:
            all_pages (bool): Whether to retrieve all pages of results or just the first page.
                Default is True.
            sort (int): An integer representing the sorting method to use.
                Default is 0.
            count (int): The number of results to retrieve per page.
                Default is 500.
            object_name (str): The name of the object to retrieve.
                Default is "Intervention".
            page (int): The page number to start at.
                Default is 1.
            verbose (bool): Whether to display a progress bar.
                Default is True.
            save (str): The file path to save the results to.
                Default is "./data/interventions_urls_by_deputies.json".

        Returns:
            deputies_list (dict): A dictionary where the keys are deputy names
                and the values are lists of URLs for their interventions.
        """
        deputies_list = {}

        # Get the interventions for each deputy
        pbar = tqdm(self.deputies, leave=False) if verbose else self.deputies
        for dep in pbar:
            res = self.get_deputy_interventions_list(
                dep_name=dep,
                count=count,
                object_name=object_name,
                sort=sort,
                page=page,
                all_pages=all_pages,
                max_interventions=max_interventions,
            )
            deputies_list[dep] = res

        # Save the results to a file if save path is provided
        if save:
            path = Path(save)
            path_list = list(path.parts)
            path_list.insert(-1, self.legislature_name)
            save_path = Path("").joinpath(*path_list[:-1])
            save_path.mkdir(parents=True, exist_ok=True)
            with open(save_path / path_list[-1], "w") as f:
                json.dump(deputies_list, f)
                self.deputies_list_file = str(save_path / path_list[-1])

        return deputies_list














    def fetch_interventions_of_deputy(
        self,
        dep_intervention_list,
        slug_name=None,
        max_interventions=1000,
        verbose=True,
        save="./data/",
    ):
        """Fetches the interventions from the API.

        Args:
            dep_intervention_list: A list of interventions.
                Returned from the `get_deputy_interventions_list` method.
            max_interventions: The maximum number of interventions to fetch.
                Default: 1000.
            verbose: Whether to display a progress bar.
                Default: True.

        Returns:
            A list of interventions.
        """
        # Initialize an empty list to store the interventions
        interventions = {
            "start": dep_intervention_list["start"],
            "end": dep_intervention_list["end"],
            "last_result": dep_intervention_list["last_result"],
            "interventions": [],
        }

        inters = (
            dep_intervention_list["results"][:max_interventions]
            if max_interventions
            else dep_intervention_list["results"]
        )
        # Fetch the interventions from the API
        pbar = tqdm(inters, leave=False) if verbose else inters
        for intervention in pbar:
            response = requests.get(intervention["document_url"]).json()["intervention"]
            interventions["interventions"].append(response)

        if save and slug_name:
            path = Path(save) / self.legislature_name / "interventions"
            path.mkdir(parents=True, exist_ok=True)
            with open(path /  f"{slug_name}.json", "w") as f:
                json.dump(interventions, f)

        return interventions











    # def async_fetch_interventions_of_deputy(self, dep_intervention_list, slug_name=None, max_interventions=1000, verbose=True, save="./data/"):
    #     """Fetches the interventions from the API.

    #     Args:
    #         dep_intervention_list: A list of interventions.
    #             Returned from the `get_deputy_interventions_list` method.
    #         max_interventions: The maximum number of interventions to fetch.
    #             Default: 1000.
    #         verbose: Whether to display a progress bar.
    #             Default: True.

    #     Returns:
    #         A list of interventions.
    #     """
    #     # Initialize an empty list to store the interventions
    #     interventions = {
    #         "start": dep_intervention_list["start"],
    #         "end": dep_intervention_list["end"],
    #         "last_result": dep_intervention_list["last_result"],
    #         "interventions": []
    #     }

    #     inters = dep_intervention_list["results"][:max_interventions] if max_interventions else dep_intervention_list["results"]
    #     urls = [intervention["document_url"] for intervention in inters]

    #     def process_response(response):
    #         return response.json()["intervention"]

    #     # Fetch the interventions from the API
    #     pbar = tqdm(urls, leave=False) if verbose else urls
    #     for url in pbar:
    #         action_item = async.get(url, hooks = {'response': process_response})
    #         interventions["interventions"].append(action_item)

    #     if save and slug_name:
    #         path = Path(save) / self.legislature_name / f"{slug_name}.json"
    #         path.mkdir(parents=True, exist_ok=True)
    #         with open(path, 'w') as f:
    #             json.dump(interventions, f)

    #     return interventions

    async def async_fetch_interventions_of_deputy_3(
        self,
        dep_urls,
        slug_name=None,
        max_interventions=1000,
        verbose=True,
        save="./data/"
        ):
        # Initialize an empty list to store the interventions
        interventions = {
            "start": dep_urls["start"],
            "end": dep_urls["end"],
            "last_result": dep_urls["last_result"],
            "interventions": []
        }
        inters = dep_urls["results"][:max_interventions] if max_interventions else dep_urls["results"]
        urls = [intervention["document_url"] for intervention in inters]
        pbar = tqdm(urls, leave=False) if verbose else urls

        async with aiohttp.ClientSession() as session:
            # Fetch the interventions from the API
            for url in pbar:
                async with session.get(url) as resp:
                    action_item = await resp.json(content_type=None)
                    interventions["interventions"].append(action_item["intervention"])

        if save and slug_name:
            path = Path(save) / self.legislature_name
            path.mkdir(parents=True, exist_ok=True)
            with open(path / f"{slug_name}.json", 'w') as f:
                json.dump(interventions, f)

        return interventions
